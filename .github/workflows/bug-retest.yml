name: Bug Retest (Android-Constrained Simulation)

on:
  workflow_dispatch:
    inputs:
      bug_id:
        description: "Bug ID or short label (used in run name/log only)"
        required: true
        type: string
      target_ref:
        description: "Git ref to test (branch/tag/SHA)"
        required: true
        default: main
        type: string
      scope:
        description: "Retest scope"
        required: true
        default: permissions
        type: choice
        options:
          - permissions
          - integration
          - deploy-repro
          - all
      pytest_k:
        description: "Optional pytest -k expression (for targeted bug retest)"
        required: false
        default: ""
        type: string
      fake_root:
        description: "Simulate Android fake-root mode"
        required: true
        default: "1"
        type: choice
        options:
          - "1"
          - "0"
      deploy_expect:
        description: "Only for deploy-repro: expected outcome"
        required: true
        default: reproduced
        type: choice
        options:
          - reproduced
          - fixed

run-name: >-
  bug:${{ inputs.bug_id }}
  ref:${{ inputs.target_ref }}
  scope:${{ inputs.scope }}
  fake_root:${{ inputs.fake_root }}

permissions:
  contents: read

concurrency:
  group: bug-retest-${{ github.workflow }}-${{ inputs.bug_id }}
  cancel-in-progress: true

jobs:
  retest:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      PYTHONDONTWRITEBYTECODE: "1"
      ANDROID_DATA: /data
      TERMUX_VERSION: ci-simulated
      PREFIX: /data/data/com.termux/files/usr
      ANDROID_DOCKER_FAKE_ROOT: ${{ inputs.fake_root }}
      ANDROID_DOCKER_LINK2SYMLINK: "0"
      PIP_DISABLE_PIP_VERSION_CHECK: "1"
      PYTEST_ADDOPTS: "-ra"
      REPRO_TIMEOUT_SECONDS: "240"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_ref }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip
          cache-dependency-path: requirements.txt

      - name: Enforce non-root execution
        shell: bash
        run: |
          set -euo pipefail
          echo "uid=$(id -u) user=$(id -un)"
          if [ "$(id -u)" -eq 0 ]; then
            echo "::error::CI retest must run as non-root to mirror Android constraints."
            exit 1
          fi

      - name: Install dependencies (non-root)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt
          python -m pip install PyYAML

      - name: Ensure local artifact directory
        shell: bash
        run: mkdir -p artifacts

      - name: Install CLI from README command (deploy-repro only)
        if: ${{ inputs.scope == 'deploy-repro' }}
        shell: bash
        run: |
          set -euo pipefail
          # Use a writable PREFIX in CI while still exercising installer-generated wrappers.
          export PREFIX="$HOME/.local"
          mkdir -p "$PREFIX/bin"
          echo "$PREFIX/bin" >> "$GITHUB_PATH"

          export INSTALL_VERSION="${{ inputs.target_ref }}"
          curl -fsSL "https://raw.githubusercontent.com/jinhan1414/android-docker-cli/main/scripts/install.sh" | sh

          command -v docker
          command -v docker-compose
          docker --help >/dev/null
          docker-compose --help >/dev/null

      - name: Bootstrap proot without sudo (integration/deploy only)
        if: ${{ inputs.scope == 'integration' || inputs.scope == 'all' || inputs.scope == 'deploy-repro' }}
        shell: bash
        run: |
          set -euo pipefail
          if command -v proot >/dev/null 2>&1; then
            proot --version || true
            exit 0
          fi

          echo "proot not found; trying user-space bootstrap via apt package download..."
          workdir="${RUNNER_TEMP}/proot_pkg"
          mkdir -p "${workdir}" "$HOME/.local/bin"
          cd "${workdir}"

          if command -v apt-get >/dev/null 2>&1; then
            apt-get download proot || true
          fi

          deb_file="$(ls -1 proot_*_amd64.deb 2>/dev/null | head -n1 || true)"
          if [ -n "${deb_file}" ] && command -v dpkg-deb >/dev/null 2>&1; then
            dpkg-deb -x "${deb_file}" extracted
            if [ -x extracted/usr/bin/proot ]; then
              cp extracted/usr/bin/proot "$HOME/.local/bin/proot"
              chmod +x "$HOME/.local/bin/proot"
              echo "$HOME/.local/bin" >> "$GITHUB_PATH"
            fi
          fi

          if command -v proot >/dev/null 2>&1; then
            proot --version || true
            exit 0
          fi

          echo "::error::proot is required for integration scope but is unavailable without root-level package install."
          echo "::error::Use permissions scope, or provide an environment where proot is preinstalled."
          exit 2

      - name: Run permissions retest
        if: ${{ inputs.scope == 'permissions' || inputs.scope == 'all' }}
        shell: bash
        run: |
          set -euo pipefail
          k_expr="${{ inputs.pytest_k }}"
          if [ -n "${k_expr}" ]; then
            python -m pytest tests/test_android_permissions.py -v -k "${k_expr}" \
              --junitxml=artifacts/permissions.xml
          else
            python -m pytest tests/test_android_permissions.py -v \
              --junitxml=artifacts/permissions.xml
          fi

      - name: Run integration retest
        if: ${{ inputs.scope == 'integration' || inputs.scope == 'all' }}
        shell: bash
        run: |
          set -euo pipefail
          k_expr="${{ inputs.pytest_k }}"
          if [ -n "${k_expr}" ]; then
            python -m pytest tests/test_android_integration.py -v -s -k "${k_expr}" \
              --junitxml=artifacts/integration.xml
          else
            python -m pytest tests/test_android_integration.py -v -s \
              --junitxml=artifacts/integration.xml
          fi

      - name: Run deploy-path issue retest
        if: ${{ inputs.scope == 'deploy-repro' }}
        timeout-minutes: 8
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="registry.cn-hangzhou.aliyuncs.com/hass-panel/hass-panel:latest"
          WORK_DIR="$PWD/.repro-issue4"
          COMPOSE_FILE="$WORK_DIR/docker-compose.yml"
          mkdir -p "$WORK_DIR/data"
          printf "%s\n" \
            "version: '3'" \
            "services:" \
            "  hass-panel:" \
            "    container_name: hass-panel" \
            "    image: ${IMAGE}" \
            "    restart: unless-stopped" \
            "    network_mode: host" \
            "    volumes:" \
            "      - ./data:/config/hass-panel" > "$COMPOSE_FILE"

          export ANDROID_DATA=/data
          export TERMUX_VERSION=ci-simulated
          export PREFIX=/data/data/com.termux/files/usr
          export ANDROID_DOCKER_FAKE_ROOT=${{ inputs.fake_root }}
          export ANDROID_DOCKER_LINK2SYMLINK=0

          SERVICE_CONTAINER="hass-panel"
          UP_LOG="$WORK_DIR/up.log"
          CONTAINER_LOG="$WORK_DIR/container.log"
          CONTAINER_STATE_LOG="$WORK_DIR/container-state.log"
          CONTAINER_PS_LOG="$WORK_DIR/container-ps.log"
          DOWN_LOG="$WORK_DIR/down.log"
          LOG_WAIT_SECONDS=90

          set +e
          if command -v timeout >/dev/null 2>&1; then
            timeout --kill-after=20s "${REPRO_TIMEOUT_SECONDS}s" \
              docker-compose -f "$COMPOSE_FILE" up -d >"$UP_LOG" 2>&1
          else
            docker-compose -f "$COMPOSE_FILE" up -d >"$UP_LOG" 2>&1
          fi
          up_code=$?

          logs_code=127
          ps_code=127
          container_state="missing"
          running_observed=0
          have_runtime_logs=0
          end_time=$((SECONDS + LOG_WAIT_SECONDS))
          : > "$CONTAINER_STATE_LOG"
          while [ "${SECONDS}" -lt "${end_time}" ]; do
            docker ps -a >"$CONTAINER_PS_LOG" 2>&1
            ps_code=$?
            container_state="$(awk -v cid="$SERVICE_CONTAINER" '$1==cid {print $NF; exit}' "$CONTAINER_PS_LOG" 2>/dev/null)"
            if [ -z "$container_state" ]; then
              container_state="missing"
            fi
            if [ "$container_state" = "running" ]; then
              running_observed=1
            fi

            docker logs "$SERVICE_CONTAINER" >"$CONTAINER_LOG" 2>&1
            logs_code=$?
            if [ "${logs_code}" -eq 0 ] && [ -s "$CONTAINER_LOG" ]; then
              have_runtime_logs=1
            fi

            printf 't=%ss state=%s exit=%s logs_code=%s logs_nonempty=%s\n' \
              "${SECONDS}" "${container_state}" "unknown" "${logs_code}" "${have_runtime_logs}" >> "$CONTAINER_STATE_LOG"

            # Do not exit early on "created" + non-empty startup logs.
            # Require observing running or exited to claim runtime evidence.
            if [ "${container_state}" = "exited" ] || \
               { [ "${running_observed}" -eq 1 ] && [ "${have_runtime_logs}" -eq 1 ]; }; then
              break
            fi
            sleep 2
          done

          # Refresh one last snapshot after wait loop for more accurate reporting.
          docker ps -a >"$CONTAINER_PS_LOG" 2>&1 || true
          container_state="$(awk -v cid="$SERVICE_CONTAINER" '$1==cid {print $NF; exit}' "$CONTAINER_PS_LOG" 2>/dev/null)"
          if [ -z "$container_state" ]; then
            container_state="missing"
          fi
          docker logs "$SERVICE_CONTAINER" >"$CONTAINER_LOG" 2>&1 || true
          if [ "$container_state" = "running" ]; then
            running_observed=1
          fi
          if [ -s "$CONTAINER_LOG" ]; then
            have_runtime_logs=1
          fi

          if command -v timeout >/dev/null 2>&1; then
            timeout --kill-after=10s 60s docker-compose -f "$COMPOSE_FILE" down >"$DOWN_LOG" 2>&1
          else
            docker-compose -f "$COMPOSE_FILE" down >"$DOWN_LOG" 2>&1
          fi
          down_code=$?
          set -e

          {
            echo "---- docker-compose up -d (tail -n 120) ----"
            tail -n 120 "$UP_LOG" 2>/dev/null || true
            echo "---- docker logs ${SERVICE_CONTAINER} (tail -n 120) ----"
            tail -n 120 "$CONTAINER_LOG" 2>/dev/null || true
            echo "---- container state timeline (tail -n 120) ----"
            tail -n 120 "$CONTAINER_STATE_LOG" 2>/dev/null || true
            echo "---- docker ps -a snapshot ----"
            cat "$CONTAINER_PS_LOG" 2>/dev/null || true
            echo "---- container state summary ----"
            echo "state: ${container_state}"
            echo "running_observed: ${running_observed}"
            echo "have_runtime_logs: ${have_runtime_logs}"
            echo "---- docker-compose down (tail -n 120) ----"
            tail -n 120 "$DOWN_LOG" 2>/dev/null || true
            echo "up exit code: ${up_code}"
            echo "logs exit code: ${logs_code}"
            echo "ps exit code: ${ps_code}"
            echo "down exit code: ${down_code}"
          } > artifacts/deploy-repro.stdout.log

          if [ "${have_runtime_logs}" -ne 1 ]; then
            echo "::warning::No non-empty container runtime log was captured before teardown."
          fi
          if [ "${running_observed}" -ne 1 ] && [ "${container_state}" != "running" ]; then
            echo "::warning::Container did not reach running state before teardown (state=${container_state})."
          fi

          if grep -q "proot error: '/bin/bash' is not executable" "$UP_LOG" || \
             grep -q "proot error: '/bin/bash' is not executable" "$CONTAINER_LOG"; then
            code=0
          else
            code=2
          fi

          expected="${{ inputs.deploy_expect }}"
          echo "deploy script exit code: ${code}, expected: ${expected}"
          tail -n 120 artifacts/deploy-repro.stdout.log || true

          if [ "${expected}" = "reproduced" ] && [ "${code}" -eq 0 ]; then
            echo "Result matches expectation: issue reproduced."
            exit 0
          fi

          if [ "${expected}" = "fixed" ] && [ "${code}" -eq 2 ]; then
            echo "Result matches expectation: issue not reproduced (fixed)."
            exit 0
          fi

          echo "::error::Deploy repro result does not match expected outcome."
          exit 1

      - name: Collect deploy repro logs
        if: ${{ always() && inputs.scope == 'deploy-repro' }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -f .repro-issue4/up.log ]; then
            cp .repro-issue4/up.log artifacts/deploy-repro-up.log
          fi
          if [ -f .repro-issue4/container.log ]; then
            cp .repro-issue4/container.log artifacts/deploy-repro-container.log
          fi
          if [ -f .repro-issue4/container-state.log ]; then
            cp .repro-issue4/container-state.log artifacts/deploy-repro-container-state.log
          fi
          if [ -f .repro-issue4/container-ps.log ]; then
            cp .repro-issue4/container-ps.log artifacts/deploy-repro-container-ps.log
          fi
          if [ -f .repro-issue4/down.log ]; then
            cp .repro-issue4/down.log artifacts/deploy-repro-down.log
          fi

      - name: Upload retest artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bug-retest-${{ inputs.bug_id }}-${{ github.run_number }}
          path: artifacts/
          if-no-files-found: warn
          retention-days: 3
